\import Data.Bool
\import Data.List
\import Data.Or
\import Function \hiding (isInj)
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths (pmap)
\import Paths.Meta
\import hw07 (unsuc)
\import lect05 (sigmaExt')
\import lect07 (Decide, no, yes)
\import lect10


-- 1. Пусть f : A -> B и g : B -> C ─ некоторые функции
--    Докажите, что если f и g инъективны, то g o f также инъективна
--    Докажите, что если g o f инъективна, то f также инъективна

\func o-inj {A B C : \Type} (f : A -> B) (g : B -> C) (p : isInj f) (q : isInj g) : isInj (g o f) => \lam e => p $ q e

\func o-inj' {A B C : \Type} (f : A -> B) (g : B -> C) (p : isInj (g o f)) : isInj f => \lam e => p $ pmap g e


-- 2. Определите предикат "делится на 3 или на 5" так, чтобы он возвращал утверждения
--    Докажите, что MultipleOf3Or5 вкладывается в Nat

\func isMultipleOf3Or5 (n : Nat) : \Type => (mod3 n = 0) `Or` (\Sigma (Not (mod3 n = 0)) (mod5 n = 0))

\func isMultipleOf3Or5-isProp (n : Nat) : isProp (isMultipleOf3Or5 n) => \lam x y => cases (x, y) \with {
  | inl a, inl a1 => pmap inl ext
  | inl a, inr b => absurd (b.1 a)
  | inr b, inl a => absurd (b.1 a)
  | inr b, inr b1 => pmap inr ext
}

\func MultipleOf3Or5 => \Sigma (n : Nat) (isMultipleOf3Or5 n)

\func Mul-inc (m : MultipleOf3Or5) => m.1

\func Mul-inc-isInj : isInj Mul-inc => \lam {(x, px)} {(y, py)} e => sigmaExt' e  $ \let pxy => rewrite e px \in $ isMultipleOf3Or5-isProp y pxy py


-- 3. Мы будем говорить, что тип A тривиален, если существует такой элемент в A, что любой другой элемент в A равен ему
--    Докажите, что тип A тривиален тогда и только тогда, когда A является утверждением и A населен

\func isTriv (A : \Type) => \Sigma (a : A) (\Pi (a' : A) -> a = a')

\func \infix 1 <-> (A B : \Type) => \Sigma (A -> B) (B -> A)

\func isTriv-lem (A : \Type) : isTriv A <-> (\Sigma (isProp A) A) => (forward, reverse) \where {
  \func forward {A : \Type} (ta : isTriv A) : \Sigma (isProp A) A => (\lam x y => rewriteI (ta.2 x) (ta.2 y), ta.1)
  \func reverse{A : \Type} (sa : \Sigma (isProp A) A) : isTriv A => (sa.2, \lam y => sa.1 sa.2 y)
}


-- 4. Докажите, что Or не является утверждением в общем случае

\func Or-isProp (p : \Pi {A B : \Type} (pA : isProp A) (pB : isProp B) -> isProp (Or A B)) : Empty =>
  \case (p Unit-isProp Unit-isProp) (inr ()) (inl ())


-- 5. Докажите, что LessOrEq является предикатом

\data LessOrEq (n m : Nat) : \Set0 \with
  | 0, m => z<=n
  | suc n, suc m => s<=s (LessOrEq n m)

\func LessOrEq-isProp {n m : Nat} : isProp (LessOrEq n m) => \lam x y => helper x y
  \where {
    \func helper {n m : Nat} (x y : LessOrEq n m) : x = y \elim n, m, x, y
      | 0, _, z<=n, z<=n => idp
      | suc _, suc _, s<=s x, s<=s y => pmap s<=s $ helper x y
  }


-- 6. Докажте, что ReflClosure LessOrEq не является предикатом, а ReflClosure (\lam x y => So (x < y)) является

\func \infix 4 < (n m : Nat) : Bool
  | _, 0 => false
  | 0, suc _ => true
  | suc n, suc m => n < m

\data ReflClosure (R : Nat -> Nat -> \Type) (x y : Nat)
  | refl (x = y)
  | inc (R x y)

\func ReflClosure_<-isProp (n m : Nat) : isProp (ReflClosure (\lam x y => So (x < y)) n m) => \lam x y => helper x y \where {
  \func helper {n m : Nat} (x y : ReflClosure (\lam x y => So (x < y)) n m) : x = y \elim n, m, x, y
    | 0, 0, refl p, refl p1 => pmap refl ext
    | 0, 0, _, inc r => absurd r
    | 0, 0, inc r, _ => absurd r
    | _, _, refl _, refl _ => pmap refl ext
    | 0, suc _, refl _, inc _ => contradiction
    | 0, suc _, inc _, refl _ => contradiction
    | suc _, 0, refl _, inc r => absurd r
    | _, _, inc _, inc _ => pmap inc ext
    | suc x, suc y, refl r, inc c => cases (x < y arg addPath) \with {
      | false, p => \let r' => rewrite p c \in absurd r'
      | true, p => \let r' => helper2 r \in contradiction
    }
    | suc x, suc y, inc c, refl r => cases (x < y arg addPath) \with {
      | false, p => \let r' => rewrite p c \in absurd r'
      | true, p => \let r' => helper2 r \in contradiction
    }
    | suc _, 0, inc r, _ => absurd r

  \func helper2 {x y : Nat} (_ : x = y) : x < y = false
    | {0}, {0}, p => idp
    | {suc x}, {suc y}, p => \let p' => unsuc p \in helper2 p'
}

\func ReflClosure_<=-isNotProp (p : \Pi (n m : Nat) -> isProp (ReflClosure LessOrEq n m)) : Empty => \let a => p 0 0 (inc z<=n) (refl idp) \in contradiction


-- 7. Докажите, что если тип A вкладывается в тип B и B является утверждением, то и A является утверждением

\func sub-isProp {A B : \Type} (f : A -> B) (p : isInj f) (q : isProp B) : isProp A => \lam x y => p $ q (f x) (f y)


-- 8. Докажите, что тип с разрешимым равенством является множеством

\func Dec-isSet {A : \Type} (dec : \Pi (x y : A) -> Decide (x = y)) : isSet A => setLem h1 h2 h3 h4 \where {
  \func f1 {x y : A} (d : Decide (x = y)) : \Type \elim d
    | yes a => \Sigma
    | no n => Empty

  \func h1 => \lam x y => f1 (dec x y)

  \func f2 {x y : A} (d : Decide (x = y)) : isProp (f1 d) \elim d
    | yes a => Unit-isProp
    | no n => Empty-isProp

  \func h2 => \lam x y => f2 (dec x y)

  \func f3 {x : A} (d : Decide (x = x)) : f1 d \elim d
    | yes a => ()
    | no n => absurd (n idp)

  \func h3 => \lam x => f3 (dec x x)

  \func f4 {x y : A} (d : Decide (x = y)) (p : f1 d) : x = y \elim d, p
    | yes a, p => a

  \func h4 => \lam (xy : \Sigma A A) => f4 (dec xy.1 xy.2)
}


-- 9. Если A и B являются множествами, то A `Or` B тоже является множеством

\func or-isSet {A B : \Type} (p : isSet A) (q : isSet B) : isSet (Or A B) => setLem h1 h2 h3 h4 \where {
  \func f1 (x y : Or A B) : \Type \elim x, y
    | inl x, inl y => x = y
    | inl x, inr y => Empty
    | inr x, inl y => Empty
    | inr x, inr y => x = y

  \func h1 => \lam x y => f1 x y

  \func f2 (x y : Or A B) : isProp (f1 x y) \elim x, y
    | inl x, inl y => p x y
    | inl x, inr y => Empty-isProp
    | inr x, inl y => Empty-isProp
    | inr x, inr y => q x y

  \func h2 => \lam x y => f2 x y

  \func f3 (x : Or A B) : f1 x x \elim x
    | inl a => idp
    | inr b => idp

  \func h3 => \lam x => f3 x

  \func f4 (x y : Or A B) (p : f1 x y) : x = y \elim x, y, p
    | inl x, inl y, p => pmap inl p
    | inr x, inr y, p => pmap inr p

  \func h4 => \lam {x} {y} => f4 x y
}


-- 10. Если B x является множеством, то \Pi (x : A) -> B x тоже является множеством

\func pi-isSet {A : \Type} (B : A -> \Type) (p : \Pi (x : A) -> isSet (B x)) : isSet (\Pi (x : A) -> B x) => setLem h1 h2 h3 h4 \where {
  \func f1 (x y : \Pi (x : A) -> B x) : \Type => \Pi (z : A) -> x z = y z

  \func h1 => \lam x y => f1 x y

  \func f2 (x y : \Pi (x : A) -> B x) : isProp (f1 x y) =>
    \lam p' q' => ext \lam z => ((p z) (x z) (y z)) (p' z) (q' z)

  \func h2 => \lam x y => f2 x y

  \func f3 (x : \Pi (x : A) -> B x) : f1 x x => \lam _ => idp

  \func h3 => \lam x => f3 x

  \func f4 (x y : \Pi (x : A) -> B x) (p : f1 x y) : x = y => ext p

  \func h4 => \lam {x} {y} => f4 x y
}


-- 11. Докажите, что если A является множеством, то List A также им является

\func List-isSet {A : \Type} (pA : isSet A) : isSet (List A) => setLem h1 h2 h3 h4 \where {
  \func f1 (xs ys : List A) : \Type \elim xs, ys
    | nil, nil => \Sigma
    | nil, y :: ys => Empty
    | x :: xs, nil => Empty
    | x :: xs, y :: ys => \Sigma (x = y) (f1 xs ys)

  \func h1 => \lam x y => f1 x y

  \func f2 (xs ys : List A) : isProp (f1 xs ys) \elim xs, ys
    | nil, nil => Unit-isProp
    | nil, y :: ys => Empty-isProp
    | x :: xs, nil => Empty-isProp
    | x :: xs, y :: ys => Sigma-isProp (pA x y) (f2 xs ys)

  \func h2 => \lam x y => f2 x y

  \func f3 (xs : List A) : f1 xs xs \elim xs
    | nil => ()
    | x :: xs => (idp, f3 xs)

  \func h3 => \lam x => f3 x

  \func f4 (xs ys : List A) (p : f1 xs ys) : xs = ys \elim xs, ys, p
    | nil, nil, p => idp
    | x :: xs, y :: ys, p => rewrite p.1 (pmap (:: y) (f4 xs ys p.2))

  \func h4 => \lam {x} {y} => f4 x y
}


-- Optional:
-- 12. Докажите, что n-типы замкнуты относительно образования \Pi-типов в общем случае
--     Hint: Доказательство по индукции
--     Для случая suc n нужно доказать, что если f, g : \Pi (x : A) -> B x,
--     то f = g эквивалентно \Pi (x : A) -> f x = g x

\func levelPi {A : \Type} (B : A -> \Type) (n : Nat) (p : \Pi (x : A) -> B x `hasLevel` n)
  : (\Pi (x : A) -> B x) `hasLevel` n => {?}
