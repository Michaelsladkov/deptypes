\import Data.Bool
\import Data.List
\import Data.Or
\import Function \hiding (isInj)
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths (pmap)
\import Paths.Meta
\import hw07 (unsuc)
\import lect05 (sigmaExt')
\import lect07 (Decide)
\import lect10


-- 1. Пусть f : A -> B и g : B -> C ─ некоторые функции
--    Докажите, что если f и g инъективны, то g o f также инъективна
--    Докажите, что если g o f инъективна, то f также инъективна

\func o-inj {A B C : \Type} (f : A -> B) (g : B -> C) (p : isInj f) (q : isInj g) : isInj (g o f) => \lam e => p $ q e

\func o-inj' {A B C : \Type} (f : A -> B) (g : B -> C) (p : isInj (g o f)) : isInj f => \lam e => p $ pmap g e


-- 2. Определите предикат "делится на 3 или на 5" так, чтобы он возвращал утверждения
--    Докажите, что MultipleOf3Or5 вкладывается в Nat

\func isMultipleOf3Or5 (n : Nat) : \Type => (mod3 n = 0) `Or` (\Sigma (Not (mod3 n = 0)) (mod5 n = 0))

\func isMultipleOf3Or5-isProp (n : Nat) : isProp (isMultipleOf3Or5 n) => \lam x y => cases (x, y) \with {
  | inl a, inl a1 => pmap inl ext
  | inl a, inr b => absurd (b.1 a)
  | inr b, inl a => absurd (b.1 a)
  | inr b, inr b1 => pmap inr ext
}

\func MultipleOf3Or5 => \Sigma (n : Nat) (isMultipleOf3Or5 n)

\func Mul-inc (m : MultipleOf3Or5) => m.1

\func Mul-inc-isInj : isInj Mul-inc => \lam {(x, px)} {(y, py)} e => sigmaExt' e  $ \let pxy => rewrite e px \in $ isMultipleOf3Or5-isProp y pxy py


-- 3. Мы будем говорить, что тип A тривиален, если существует такой элемент в A, что любой другой элемент в A равен ему
--    Докажите, что тип A тривиален тогда и только тогда, когда A является утверждением и A населен

\func isTriv (A : \Type) => \Sigma (a : A) (\Pi (a' : A) -> a = a')

\func \infix 1 <-> (A B : \Type) => \Sigma (A -> B) (B -> A)

\func isTriv-lem (A : \Type) : isTriv A <-> (\Sigma (isProp A) A) => (forward, reverse) \where {
  \func forward {A : \Type} (ta : isTriv A) : \Sigma (isProp A) A => (\lam x y => rewriteI (ta.2 x) (ta.2 y), ta.1)
  \func reverse{A : \Type} (sa : \Sigma (isProp A) A) : isTriv A => (sa.2, \lam y => sa.1 sa.2 y)
}


-- 4. Докажите, что Or не является утверждением в общем случае

\func Or-isProp (p : \Pi {A B : \Type} (pA : isProp A) (pB : isProp B) -> isProp (Or A B)) : Empty =>
  \case (p Unit-isProp Unit-isProp) (inr ()) (inl ())


-- 5. Докажите, что LessOrEq является предикатом

\data LessOrEq (n m : Nat) : \Set0 \with
  | 0, m => z<=n
  | suc n, suc m => s<=s (LessOrEq n m)

\func LessOrEq-isProp {n m : Nat} : isProp (LessOrEq n m) => \lam x y => helper x y
  \where {
    \func helper {n m : Nat} (x y : LessOrEq n m) : x = y \elim n, m, x, y
      | 0, _, z<=n, z<=n => idp
      | suc _, suc _, s<=s x, s<=s y => pmap s<=s $ helper x y
  }


-- 6. Докажте, что ReflClosure LessOrEq не является предикатом, а ReflClosure (\lam x y => So (x < y)) является

\func \infix 4 < (n m : Nat) : Bool
  | _, 0 => false
  | 0, suc _ => true
  | suc n, suc m => n < m

\data ReflClosure (R : Nat -> Nat -> \Type) (x y : Nat)
  | refl (x = y)
  | inc (R x y)

\func ReflClosure_<-isProp (n m : Nat) : isProp (ReflClosure (\lam x y => So (x < y)) n m) => \lam x y => helper x y \where {
  \func helper {n m : Nat} (x y : ReflClosure (\lam x y => So (x < y)) n m) : x = y \elim n, m, x, y
    | 0, 0, refl p, refl p1 => pmap refl ext
    | 0, 0, _, inc r => absurd r
    | 0, 0, inc r, _ => absurd r
    | _, _, refl _, refl _ => pmap refl ext
    | 0, suc _, refl _, inc _ => contradiction
    | 0, suc _, inc _, refl _ => contradiction
    | suc _, 0, refl _, inc r => absurd r
    | _, _, inc _, inc _ => pmap inc ext
    | suc x, suc y, refl r, inc c => cases (x < y arg addPath) \with {
      | false, p => \let r' => rewrite p c \in absurd r'
      | true, p => \let r' => helper2 r \in contradiction
    }
    | suc x, suc y, inc c, refl r => cases (x < y arg addPath) \with {
      | false, p => \let r' => rewrite p c \in absurd r'
      | true, p => \let r' => helper2 r \in contradiction
    }
    | suc _, 0, inc r, _ => absurd r

  \func helper2 {x y : Nat} (_ : x = y) : x < y = false
    | {0}, {0}, p => idp
    | {suc x}, {suc y}, p => \let p' => unsuc p \in helper2 p'
}

\func ReflClosure_<=-isNotProp (p : \Pi (n m : Nat) -> isProp (ReflClosure LessOrEq n m)) : Empty => \let a => p 0 0 (inc z<=n) (refl idp) \in contradiction


-- 7. Докажите, что если тип A вкладывается в тип B и B является утверждением, то и A является утверждением

\func sub-isProp {A B : \Type} (f : A -> B) (p : isInj f) (q : isProp B) : isProp A => \lam x y => p $ q (f x) (f y)


-- 8. Докажите, что тип с разрешимым равенством является множеством

\func Dec-isSet {A : \Type} (dec : \Pi (x y : A) -> Decide (x = y)) : isSet A => {?}


-- 9. Если A и B являются множествами, то A `Or` B тоже является множеством

\func or-isSet {A B : \Type} (p : isSet A) (q : isSet B) : isSet (Or A B) => {?}


-- 10. Если B x является множеством, то \Pi (x : A) -> B x тоже является множеством

\func pi-isSet {A : \Type} (B : A -> \Type) (p : \Pi (x : A) -> isSet (B x)) : isSet (\Pi (x : A) -> B x) => {?}


-- 11. Докажите, что если A является множеством, то List A также им является

\func List-isSet {A : \Type} (pA : isSet A) : isSet (List A) => {?}


-- Optional:
-- 12. Докажите, что n-типы замкнуты относительно образования \Pi-типов в общем случае
--     Hint: Доказательство по индукции
--     Для случая suc n нужно доказать, что если f, g : \Pi (x : A) -> B x,
--     то f = g эквивалентно \Pi (x : A) -> f x = g x

\func levelPi {A : \Type} (B : A -> \Type) (n : Nat) (p : \Pi (x : A) -> B x `hasLevel` n)
  : (\Pi (x : A) -> B x) `hasLevel` n => {?}
