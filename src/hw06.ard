\import Data.Bool
\import Data.Maybe
\import Logic
\import Paths
\import Topology.CoverSpace.Locale
\import hw01 (gcd)
\import lect05 (funExt)
\import lect06

-- 1. Определите функцию swap несколькими способами

-- При помощи \cowith и доступа к полям
\func swap {A B : \Type} (p : Pair A B) : Pair B A \cowith
  | fst_ => p.snd_
  | snd_ => p.fst_

-- При помощи \new и паттерн матчинга
\func swap' {A B : \Type} (_ : Pair A B) : Pair B A
  | (a, b) => \new Pair {
    | fst_ => b
    | snd_ => a
  }

-- При помощи \new и доступа к полям
\func swap'' {A B : \Type} (p : Pair A B) : Pair B A => \new Pair {
  | fst_ => p.snd_
  | snd_ => p.fst_
}

-- 2. Докажите, что swap (swap p) = p

\func swap-involutive {A B : \Type} (p : Pair A B) : swap (swap p) = p => idp

-- 3. Докажите, что тип PosNat 0 пустой, а тип PosNat 1 нет

\func zero-isNotPos (p : PosNat 0) : Empty => \case p.p \with {}

\func one-isPos : PosNat 1 => \new PosNat {
  | n => 1
  | p => ()
}

-- 4. Определите \record, состоящий из пар взаимно простых натуральных чисел
--    Определите тип, состоящий из натуральных чисел, взаимно простых с 60

\record MutuallyPrime (x : Nat) (y : Nat) (p : gcd x y = 1)
  -- test
\func three-four-mutuallyPrime : MutuallyPrime 3 4 => \new MutuallyPrime {
  | p => idp
}
-- Correctly fails
-- \func three-six-mutuallyPrime : MutuallyPrime 3 6 => \new MutuallyPrime {
--   | p => idp
-- }

\func primeWith60 => \Sigma (x : Nat) (p : MutuallyPrime x 60)

-- 5. Закончите определение класса монад
--    Этот класс должен содержать все монадные законы и реализовывать все поля из класса функторов

\class Monad \extends Functor {
  | return {A : \Type} : A -> F A
  | \infixl 2 >>= {A B : \Type} : F A -> (A -> F B) -> F B
  | law1 {A B : \Type} (a : A) (f : A -> F B) : return a >>= f = f a
  | law2 {A : \Type} (m : F A) : m >>= return = m
  | law3 {A B C : \Type} (m : F A) (k : A -> F B) (h : B -> F C) : m >>= (\lam x => k x >>= h) = (m >>= k) >>= h
  | fmap f as => as >>= (\lam x => return (f x))
  | fmap-id {A : \Type} (x : F A) => law2 x
  | fmap-comp {A B C : \Type} (f : B -> C) (g : A -> B) (x : F A) => \let
    | rf => \lam x => return (f x)
    | rg => \lam x => return (g x)
    | h2 (a : A) : return (f (g a)) = return (g a) >>= rf => inv (law1 (g a) rf *> idp)
    | h1 : x >>= (\lam b => return (f (g b))) = x >>= (\lam b => return (g b) >>= rf) => pmap (\lam ff => x >>= ff) (funExt (\lam b => h2 b))
    \in h1 *> law3 x rg rf
}

-- 6. Определите \instance Monad для Maybe

\instance MonadMaybe : Monad Maybe
  | return {A : \Type} (a : A) => just a
  | >>= {A B : \Type} (a : Maybe A) (f : A -> Maybe B) : Maybe B \elim a {
    | nothing => nothing
    | just a => f a
  }
  | law1 {A B : \Type} (_ : A) (_ : A -> Maybe B) => idp
  | law2 {A : \Type} (m : Maybe A) : m >>= just = m \elim m {
    | nothing => idp
    | just a => idp
  }
  | law3 {A B C : \Type}
         (m : Maybe A)
         (k : A -> Maybe B)
         (h : B -> Maybe C) : m >>= (\lam x => k x >>= h) = (m >>= k) >>= h \elim m {
    | nothing => idp
    | just a => idp
  }



-- 7. Определите \instance Monad для State и State'

\record State (S A : \Type)
  | state : S -> \Sigma S A

\data State' (S A : \Type)
  | state' (S -> \Sigma S A)
