\import Data.Bool
\import Function
\import Logic (<->)
\import Meta
\import lect11


-- 1. Докажите, что если A : \Prop, то Trunc A эквивалентен A

\func trunc-prop {A : \Prop} : Trunc A <-> A => (forward, reverse) \where {
  \func reverse {A : \Prop} (a : A) : Trunc A => trunc a
  \func forward{A : \Prop}  (t : Trunc A) : A \elim t
    | trunc a => a
}

-- 2. Докажите следующий закон де Моргана

\func deMorgan (A B C : \Prop) : (\Sigma A (B `Or` C)) <-> ((\Sigma A B) `Or` (\Sigma A C)) => (forward, reverse) \where {

  \func reverse {A B C : \Prop} (s2 : (\Sigma A B) `Or` (\Sigma A C)) :  \Sigma A (B `Or` C) \elim s2
    | inl a => (a.1, inl a.2)
    | inr b => (b.1, inr b.2)

  \func forward
    {A B C : \Prop}
    (s1 : \Sigma A (B `Or` C))
    : (\Sigma A B) `Or` (\Sigma A C) => cases (s1.1, s1.2) \with {
    | x, inl a => inl (x, a)
    | x, inr b => inr (x, b)
  }
}


-- 3. Определите элиминатор для Or через Or-rec, не используя паттерн матчинг на Or

\func Or-elim {A B : \Prop} (C : Or A B -> \Prop)
              (f : \Pi (x : A) -> C (inl x)) (g : \Pi (y : B) -> C (inr y))
              (p : A `Or` B) : C p => Or-rec f-helper g-helper p \where {
    \func g-helper (b : B) : C p => transport g {?} b
    \func f-helper (a : A) : C p => {?}
}


-- 4. Докажите, что тип утверждений является множеством

\func prop-isSet : isSet \Prop => \lam x y x1 y1 => {?}


-- 5. Докажите, что функции Prop1-to-Prop2 и Prop2-to-Prop1 взаимно обратны и, как следствие, что Prop1 = Prop2


-- Можно сделать только одно из упражнений 6a, 6b на выбор

-- 6a. Тип С называется когенератором, если для любых множеств A и B и любых функций f, g : A -> B верно,
--     что если h o f = h o g для всех h : B -> C, то f = g
--     Докажите, что \Prop является когенератором

\func isCogenerator (C : \Type) => \Pi {A B : \Set} (f g : A -> B) (p : \Pi (h : B -> C) -> h o f = h o g) -> f = g

\func PropIsCogenerator : isCogenerator \Prop => {?}

-- 6b. Тип X называется инъективным, если для любой функции f : A -> X и любой инъекции i : A -> B
--     существует функция l : B -> X такая, что l o i = f
--     Докажите, что \Prop инъективен

\func isInj {A B : \Type} (f : A -> B) => \Pi (x y : A) -> f x = f y -> x = y

\func isInjective (X : \Type) =>
  \Pi {A B : \Type} (f : A -> X) (i : A -> B) (p : isInj i) -> \Sigma (l : B -> X) (l o i = f)

\func Prop-isInjective : isInjective \Prop => {?}


-- Можно сделать только одно из упражнений 7a, 7b на выбор

-- 7a. Докажите, что (Bool = Bool) = Bool

\func BoolAut : (Bool = Bool) = Bool => {?}

-- 7b. Докажите, что (n+m)-элементное множество равно размеченному объединению n- и m-элементных множеств
